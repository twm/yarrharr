const webpack = require('webpack');
const path = require('path');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');
const TerserPlugin = require('terser-webpack-plugin');
const FaviconPlugin = require('./favicon.js');

/**
 * Yarrharr's Webpack build has three modes, defined by these constants. The
 * RUNMODE environment variable must have one of these values.
 *
 * - RELEASE — production build with minification, etc. Artifacts are written
 *   to yarrharr/static/ with content-hashed filenames.
 * - DEV_STATIC — like the development build but still has debug assertions.
 * - DEV_HOT — webpack-dev-server with hot module replacement enabled. This
 *   also requires a running Django development server (see the readme).
 */
const RELEASE = 'release';
const DEV_STATIC = 'dev-static';
const DEV_HOT = 'dev-hot';

const runmode = process.env.RUNMODE;
if (![RELEASE, DEV_STATIC, DEV_HOT].includes(runmode)) {
    throw new Error(`Invalid RUNMODE environment variable '${runmode}'`);
}

/**
 * Replace "[hash]" and "[contenthash]" with "hot", as expected for hot module
 * reloading.
 *
 * This must match the name generated by the latest_static Django template tag
 * defined in yarrharr/templatetags/static_glob.js
 */
function hotify(namePattern) {
    if (runmode === DEV_HOT) {
        return namePattern.replace(/\[(content)?hash\]/, 'hot');
    }
    return namePattern;
}

const config = {
    mode: runmode === RELEASE ? 'production' : 'development',
    entry: './assets/entry.js',
    resolve: {
        modules: [
            path.join(__dirname, 'assets'),
            'node_modules',
        ],
        extensions: [
            '.js',
            '.jsm',
        ],
    },
    module: {
        rules: [{
        // FIXME WP4: Restore eslint
            // test: /\.jsm?$/,
            // enforce: 'pre',
            // loaders: ['eslint-loader'],
            // exclude: /node_modules/,
        // }, {
            test: /\.less$/,
            use: [{
                // Use style-loader for hot module reloading. Otherwise extract
                // CSS to files.
                loader: runmode === DEV_HOT ? 'style-loader' : MiniCssExtractPlugin.loader,
            }, {
                loader: 'css-loader',
                options: {sourceMap: true}
            }, {
                loader: 'less-loader',
                options: {strictMath: true, noIeCompat: true, sourceMap: true},
            }],
        }, {
            test: /\.jsm?$/,
            loaders: ['babel-loader'],
            exclude: /node_modules/,
        }, {
            // Files that must currently be used as images because they are
            // included from non-React pages:
            test: /assets\/art\/(icon|logotype|lettertype)\.svg$/,
            use: [{
                loader: 'file-loader',
                options: {
                    name: hotify('[name]-[hash].[ext]'),
                },
            }],
        }],
    },
    output: {
        path: path.resolve(__dirname, 'yarrharr/static'),
        filename: hotify('[name]-[contenthash].js'),
    },
    plugins: [
        new MiniCssExtractPlugin({
            filename: hotify("[name]-[contenthash].css"),
        }),
        new FaviconPlugin(),
        new webpack.DefinePlugin({
            __debug__: JSON.stringify(runmode !== RELEASE),
            __hot__: JSON.stringify(runmode === DEV_HOT),
        }),
    ],
    devtool: "source-map",
    optimization: {
        minimizer: [
            new TerserPlugin({
                terserOptions: {
                    ecma: 6,
                    module: true,
                    compress: {
                        global_defs: {
                            // Tersify refuses to do code elimination when the constant is defined
                            // as "const __debug__ = process.env.NODE_ENV !== 'production'": it
                            // translates that comparison to false (actually !1) but doesn't
                            // propagate the value like uglify did. However, if we define __debug__
                            // directly here code elimination works.
                            __debug__: runmode !== RELEASE,
                        },
                    },
                    mangle: {
                        // Never mangle these names so that the build script can grep for them as
                        // a sanity check. Note that propTypes would normally never be mangled, but
                        // __debug__ would be.
                        reserved: ['__debug__', 'propTypes'],
                    },
                    output: {
                        // Keep the line length sane to make inspecting the bundle easier.
                        max_line_len: 180,
                        // TODO: Insert a license comment.
                    },
                },
            }),
        ],
        runtimeChunk: 'single',
        splitChunks: {
            cacheGroups: {
                vendor: {
                    test: /[\\\/]node_modules[\\\/]/,
                    name: 'vendor',
                    chunks: 'all'
                },
            },
        },
    },
};

if (runmode === DEV_HOT) {
    // The publicPath seems to be required for HMR but we don't want to
    // hardcode it in other runmodes because the deployment address is not
    // known.
    config.output.publicPath = 'http://127.0.0.1:8888/static/';
    config.plugins.push(new webpack.HotModuleReplacementPlugin());
    config.devServer = {
        allowedHosts: ['127.0.0.1'],
        host: '127.0.0.1',
        port: 8888,
        hot: true,
        index: '', // Proxy / instead of serving a file.
        proxy: {
            '/': 'http://127.0.0.1:8887',  // Django dev server.
        },
        publicPath: '/static/',
        contentBase: path.join(__dirname, 'yarrharr/static'),
    };
}

module.exports = config;
